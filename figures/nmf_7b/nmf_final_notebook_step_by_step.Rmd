---
title: "R Notebook"
output: html_notebook
---

# Imports


```{r}

# path to save everything
dir_to_save_fig <-  "../../output_figures/NMF/"
dir.create(file.path(".", dir_to_save_fig), showWarnings = F, recursive = T)

unloadNamespace("linseed2")
devtools::load_all(path='../../../linseed2/')
source('nmf_methods.R')
```

# Syntetic experiment 

(to visualize and check that everything work)
## Make NMF Data matrix

```{r}
components_count <-  c(3, 4, 5)
mixtures_count <-  c(25, 50, 100, 500)
features_count <- c(200, 500, 1000, 2000)

```

```{r}
current_K <- components_count[[2]]
current_M <- features_count[[2]]
current_N <- mixtures_count[[1]]
```


```{r}
global_generated_data <- make_syntetic_data(M=current_M, N=current_N, K=current_K)
```


```{r}
plot_w_h_v(global_generated_data$true_W, global_generated_data$true_H, global_generated_data$V)
```


## Solve this NMF with different methods

```{r}
res_methods <- nmf(global_generated_data$V, current_K, list('lee', 'brunet', 'nsNMF'), nrun=10, .options='kt')
```

# Solve using Dual Simplex Method


```{r}
res <- nmf(global_generated_data$V, current_K, linseedv2_nmf_algorithm, nrun=10, .options='tk', name="Linseedv2 NMF")
res_methods[["Linseedv2 NMF"]] <- res
```


## Check results
### Triangles found by linseed
```{r}
#check_triangles(res_methods)
```

### Matrices for each algorithm
```{r}
lapply(res_methods, function (method_result_list){
  method_result <- method_result_list[[1]] 
  current_W <- method_result@fit@W
  current_H <- method_result@fit@H
  plot_w_h_v(current_W, current_H, current_W %*% current_H, method_result@method)
  
})
```
### RMSE errors

```{r, fig.height = 5, fig.width=20}
library(dplyr)
data_used <- rep(list(global_generated_data), 10)
distances_to_check <- plot_metrics(res_methods = res_methods, data_used=data_used)
```

```{r, fig.height = 5, fig.width=20}
data_used <- rep(list(global_generated_data), 10)
distances_to_check <- plot_metrics_box(res_methods = res_methods, data_used=data_used)
distances_to_check$plot
```

## Check how different parameters (K, M, N ) will change results

### Define experiment method

#### Single data matrix multiple run (statistics for different runs)
```{r}
run_experiment_syntetic_single_data <- function(current_K, current_M, current_N) {
  
  syntetic_data <- make_syntetic_data(M=current_M, N=current_N, K=current_K)
  plot_w_h_v(syntetic_data$true_W, syntetic_data$true_H, syntetic_data$V)
  
  
  
  res_methods <- nmf(syntetic_data$V, current_K, list('lee', 'brunet', 'nsNMF'), nrun=10, .options='kt')
  #linseed
  res <- nmf(syntetic_data$V, current_K, linseedv2_nmf_algorithm, nrun=10, .options='tkp1', name="Linseedv2 NMF")
  
  res_methods[["Linseedv2 NMF"]] <- res
  
  
  lapply(res_methods, function (method_result_list){
    method_result <- method_result_list[[2]] 
    current_W <- method_result@fit@W
    current_H <- method_result@fit@H
    plot_w_h_v(current_W, current_H, current_W %*% current_H, method_result@method)
  })
  
  plot_metrics(res_methods = res_methods, 
               curr_data=syntetic_data, 
               title=paste("K =", as.character(current_K), "M =", as.character(current_M),"N =",as.character(current_N)))
  return (res_methods)
}
```


#### Multiple data matrix multiple run (statistics for different matrices)
```{r}
# run all these steps for single data matrix
run_experiment_syntetic_single_data <- function(current_K, current_M, current_N) {
  syntetic_data <- make_syntetic_data(M=current_M, N=current_N, K=current_K)
  plot_w_h_v(syntetic_data$true_W, syntetic_data$true_H, syntetic_data$V)
  res_methods <- nmf(syntetic_data$V, current_K, list('lee', 'brunet', 'nsNMF'), nrun=10, .options='kt')
  #linseed
  res <- nmf(syntetic_data$V, current_K, linseedv2_nmf_algorithm, nrun=10, .options='tkp1', name="Linseedv2 NMF")
  
  res_methods[["Linseedv2 NMF"]] <- res
  
  
  lapply(res_methods, function (method_result_list){
    
    
    method_result <- method_result_list[[2]] 
    current_W <- method_result@fit@W
    current_H <- method_result@fit@H
    plot_w_h_v(current_W, current_H, current_W %*% current_H, method_result@method)
    
  })
  plot_metrics(res_methods = res_methods, curr_data=syntetic_data, title=paste("K =", as.character(current_K), "M =", as.character(current_M),"N =",as.character(current_N)))
  return (res_methods)

}

# Compare between different data generations
run_experiment_syntetic <- function(current_K, current_M, current_N, n_data_generations = 3) {
  
  lee_results <- c()
  brunet_results <- c()
  nsNMF_results <- c()
  linseed_results <- c()
  
  data_generated <- lapply(c(1:n_data_generations), function(run_index) make_syntetic_data(M=current_M, N=current_N, K=current_K))
  
  total_result <- lapply(c(1:n_data_generations), function(run_index) {
      print(paste("data gen ", run_index))
      syntetic_data <- data_generated[[run_index]]
      current_res_methods <- nmf(syntetic_data$V, current_K, list('lee', 'brunet', 'nsNMF'), nrun=10)
      linseed_res <- nmf(syntetic_data$V, current_K, linseedv2_nmf_algorithm, nrun=10, .options='tp1', name="Linseedv2 NMF")
      current_res_methods[["Linseedv2 NMF"]] <- linseed_res
      return(current_res_methods)
  })

  
  all_results_flat <- unlist(total_result, recursive = F)
  unique_names <- unique(names(all_results_flat))
  per_method_per_run_result <- lapply(unique_names, function(cur_nm) all_results_flat[names(all_results_flat) == cur_nm])
  names(per_method_per_run_result) <- unique_names
  distances_to_check <- plot_metrics(res_methods = per_method_per_run_result, data_used=data_generated, title=paste("K =", as.character(current_K), "M =", as.character(current_M),"N =",as.character(current_N)))

  
  return (list(data_used=data_generated, fit_objects=per_method_per_run_result, distances_to_check=distances_to_check))

}

```


# Pictures

```{r}
library(linseed)
library(raster)
```

## Read pictures (components)
```{r}
size <- 128
number_of_pictures_to_select <- 4

pictures_W <- rhdf5::h5read("img/merged_imgs.h5", "matrix")
pictures_W <- t(pictures_W)[,1:number_of_pictures_to_select]

current_M <- nrow(pictures_W)
current_K <- ncol(pictures_W)
```


## Check pictures generation mixtures from simplex

```{r}
current_N <- 100
globally_generated_pic_data <- make_picture_data(current_M, current_N, current_K, pictures_W)
```

```{r}
plot_w_h_v(globally_generated_pic_data$true_W, globally_generated_pic_data$true_H, globally_generated_pic_data$V)
```

## Simplex generated proportions
Here proporition matrix H should be obtained using simplex

### Define experiment method

```{r}
run_experiment_picture_simplex <- function(current_K, current_M, current_N, pictures_W, n_data_generations = 3 ) {
  
  lee_results <- c()
  brunet_results <- c()
  nsNMF_results <- c()
  linseed_results <- c()
  data_generated <- lapply(c(1:n_data_generations), function(run_index) make_picture_data(current_M, current_N, current_K, pictures_W))
  
  total_result <- lapply(c(1:n_data_generations), function(run_index) {
      print(paste("data gen ", run_index))
      syntetic_data <- data_generated[[run_index]]
      current_res_methods <- nmf(syntetic_data$V, current_K, list('lee', 'brunet', 'nsNMF'), nrun=10)
      linseed_res <- nmf(syntetic_data$V, 
                         current_K, 
                         linseedv2_nmf_algorithm, 
                         nrun=10, .options='t', name="Linseedv2 NMF")
      current_res_methods[["Linseedv2 NMF"]] <- linseed_res
      return(current_res_methods)
  })
  
  
  all_results_flat <- unlist(total_result, recursive = F)
  unique_names <- unique(names(all_results_flat))
  per_method_per_run_result <- lapply(unique_names, function(cur_nm) all_results_flat[names(all_results_flat) == cur_nm])
  names(per_method_per_run_result) <- unique_names
 # distances_to_check <- plot_metrics(res_methods = per_method_per_run_result, data_used=data_generated, title=paste("K =", as.character(current_K), "M =", as.character(current_M),"N =",as.character(current_N)))

  
  return (list(data_used=data_generated, fit_objects=per_method_per_run_result))

}
```

### Make solution


```{r, fig.height = 5, fig.width=20}
result <- run_experiment_picture_simplex(current_K = current_K, current_M= current_M, current_N = current_N, n_data_generations = 10, pictures_W = pictures_W )
```
### Plot boxplot of distances to check if everthing is fine

```{r, fig.height = 5, fig.width=20}
distances_to_check <- plot_metrics_box(res_methods = result$fit_objects, data_used=result$data_used, title=paste("K =", as.character(current_K), "M =", as.character(current_M),"N =",as.character(current_N)))
result$distances_to_check <- distances_to_check
distances_to_check$plot
```

### Plot result pictures
```{r}
plot_pictures_for_result(result$fit_objects, model_index = 1)
```
### Save RDS with results
```{r}
result_simplex <- result

file_name <- paste0(dir_to_save_fig, 'pictures_', current_K ,'K_', current_N, 'N_', current_M, 'M_simplex-H_10runs_10init.rds')

saveRDS(result_simplex, file=file_name)
```



## Completely Random matrix H


### Define experiment method

```{r}
run_experiment_picture_random <- function(current_K, current_M, current_N, pictures_W, n_data_generations = 3 ) {
  
  lee_results <- c()
  brunet_results <- c()
  nsNMF_results <- c()
  linseed_results <- c()
  data_generated <- lapply(c(1:n_data_generations), function(run_index) make_picture_data_random_mixtures(current_M, current_N, current_K, pictures_W))
  
  total_result <- lapply(c(1:n_data_generations), function(run_index) {
      print(paste("data gen ", run_index))
      syntetic_data <- data_generated[[run_index]]
      current_res_methods <- nmf(syntetic_data$V, current_K, list('lee', 'brunet', 'nsNMF'), nrun=10)
      linseed_res <- nmf(syntetic_data$V, current_K, linseedv2_nmf_algorithm, nrun=10, .options='t', name="Linseedv2 NMF")
      current_res_methods[["Linseedv2 NMF"]] <- linseed_res
      return(current_res_methods)
  })
  
  
  all_results_flat <- unlist(total_result, recursive = F)
  unique_names <- unique(names(all_results_flat))
  per_method_per_run_result <- lapply(unique_names, function(cur_nm) all_results_flat[names(all_results_flat) == cur_nm])
  names(per_method_per_run_result) <- unique_names
  return (list(data_used=data_generated, fit_objects=per_method_per_run_result))
}


```

### Get solution for all methods
```{r, fig.height = 5, fig.width=20}
result_random <- run_experiment_picture_random(current_K = current_K, current_M= current_M, current_N = current_N, n_data_generations = 10, pictures_W = pictures_W )
```

### Make boxplot to original matrices to check if everything is fine
```{r, fig.height = 5, fig.width=20}
distances_to_check <- plot_metrics_box(res_methods = result_random$fit_objects, 
                                       data_used=result_random$data_used, 
                                       title=paste("K =", as.character(current_K), "M =", as.character(current_M),"N =",as.character(current_N)))

result_random$distances_to_check <- distances_to_check
```

### Check how triangles look like

```{r}
check_triangles(result_random$fit_objects)
```
## Save RDS with results

```{r}
file_name <- paste0(dir_to_save_fig, 'pictures_', current_K ,'K_', current_N, 'N_', current_M, 'M_random-H_10runs_10init.rds')

saveRDS(result_random, file=file_name)
```


